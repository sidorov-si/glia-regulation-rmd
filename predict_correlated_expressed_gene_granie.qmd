---
title: "Transcription regulation in gliogenesis"
author: "Sviatoslav Sidorov"
format: html
editor: visual
---

## Load libraries

```{r}
library(GRaNIE)
library(dplyr)
library(stringr)
library(tibble)
library(magrittr)
library(DESeq2)
library(biomaRt)
```

## Define constants and helper functions

```{r}
# Define helper functions
source("helper_functions_granie.R")

# Min norm mean counts to filter genes and regions (peaks)
min.norm.rna.counts = 10 # 5, 20
min.norm.peak.counts = 10 # 5, 20

# Radius of region-gene assignment vicinities around regions
vicinity.radius = 500000 # bp

# Prefix of gene names to exclude from the analysis
genes.to.exclude = "ERCC-" # exclude spike-in control

# Parameters for choosing significantly regulated regions
# fdr = 0.01
# min.l2fc = 2 # Min log2(fold change) | 1
# min.baseMean = 100 # 20, 40

# FDR for NFIA motif matches
# fdr.matches = 0.05
```

## Preprocess gene expression counts

Load gene expression raw counts, exclude the spike-in control and retain only WT samples from Day 7, 9 or 11:

```{r}
master_table_genes = assays(readRDS("../input/salmon.merged.gene_counts.rds"))$counts %>%
  rownames_to_column(var = "gene_name") %>%
  filter(!stringr::str_detect(gene_name, fixed(genes.to.exclude))) %>%
  column_to_rownames(var = "gene_name") %>%
  dplyr::select(all_of(names(.)[stringr::str_detect(names(.), "WT_D[179]+_")]))
```

Add Ensembl IDs to all genes and exclude genes without Ensembl IDs. Use Ensembl v102, as it is the last version of the Ensembl database whose dataset `mmusculus_gene_ensembl` is still based on the reference assembly GRCm38 which corresponds to the assembly mm10 used in the expression and chromatin accessibility quantification:

```{r}
gene_id_name = read.delim("../input/ensembl102_grcm38p6_gene_id_names.tsv",
                           header = F,
                           sep = "\t") %>%
  dplyr::rename("gene_id" = "V1",
                "gene_name" = "V2")

master_table_genes %<>%
  rownames_to_column(var = "gene_name") %>%
  left_join(gene_id_name,
            by = c("gene_name" = "gene_name")) %>%
  filter(!is.na(gene_id)) %>%
  dplyr::select(-gene_name) %>%
  dplyr::select(gene_id,
                all_of(names(.)[stringr::str_detect(names(.), "WT_D[179]+_")]))

# Some genes have more than one Ensembl ID, hence the warning.

# Table ../input/ensembl102_grcm38p6_gene_id_names.tsv was obtained using the following commands:

# ensembl = useEnsembl(biomart = "ensembl",
#                      dataset = "mmusculus_gene_ensembl",
#                      version = "102")
# 
# gene_id_name = getBM(attributes = c("ensembl_gene_id",
#                                     "external_gene_name"),
#                      mart = ensembl)
# 
# write.table(gene_id_name,
#             "../input/ensembl102_grcm38p6_gene_id_names.tsv",
#             quote = F,
#             sep = "\t",
#             row.names = F,
#             col.names = F)
```

Generate domain-specific gene expression tables with raw counts:

```{r}
p1_gene_expression = master_table_genes %>%
  dplyr::select(gene_id, 
                all_of(names(.)[stringr::str_detect(names(.), "p1")]))

p2_gene_expression = master_table_genes %>%
  dplyr::select(gene_id, 
                all_of(names(.)[stringr::str_detect(names(.), "p2")]))

pM_gene_expression = master_table_genes %>%
  dplyr::select(gene_id,
                all_of(names(.)[stringr::str_detect(names(.), "pM")]))
```

Unload the gene expression master table from memory:

```{r}
rm(master_table_genes)
```

## Preprocess region accessibility counts

Load raw accessibility counts, retain only WT samples from Day 7, 9 or 11 and create the region annotation:

```{r}
master_table_regions = read.delim(file = "../input/consensus_peaks.mRp.clN.featureCounts.txt",
                                  header = T,
                                  sep = "\t",
                                  skip = 1)

names(master_table_regions) = gsub(pattern = ".mLb.clN.bam", 
                                   replacement = "", 
                                   x = names(master_table_regions))

region_annot = master_table_regions %>%
  dplyr::select(Geneid,
                Chr,
                Start,
                End,
                Strand,
                Length)

master_table_regions %<>%
  mutate(region_id = paste0(Chr, ":", Start, "-", End)) %>%
  dplyr::select(region_id, 
                all_of(names(.)[stringr::str_detect(names(.), "WT_D[179]+_")]))
```

Generate domain-specific region accessibility tables with raw counts:

```{r}
p1_region_accessibility = master_table_regions %>%
  dplyr::select(region_id, 
                all_of(names(.)[stringr::str_detect(names(.), "p1")]))

p2_region_accessibility = master_table_regions %>%
  dplyr::select(region_id, 
                all_of(names(.)[stringr::str_detect(names(.), "p2")]))

pM_region_accessibility = master_table_regions %>%
  dplyr::select(region_id, 
                all_of(names(.)[stringr::str_detect(names(.), "pM")]))
```

Unload the region accessibility master table from memory:

```{r}
rm(master_table_regions)
```

## Create GRNs

Create domain-specific tables of sample metadata:

```{r}
sample_meta_p1 = generate_sample_meta(p1_gene_expression, p1_region_accessibility)

sample_meta_p2 = generate_sample_meta(p2_gene_expression, p2_region_accessibility)

sample_meta_pM = generate_sample_meta(pM_gene_expression, pM_region_accessibility)
```

Initialize GRNs:

```{r}
grn_p1 = initializeGRN(objectMetadata = list(domain = "p1"),
                       outputFolder = "../r_results/predict_correlated_expressed_gene_granie/grn_p1",
                       genomeAssembly = "mm10")

grn_p2 = initializeGRN(objectMetadata = list(domain = "p2"),
                       outputFolder = "../r_results/predict_correlated_expressed_gene_granie/grn_p2",
                       genomeAssembly = "mm10")

grn_pM = initializeGRN(objectMetadata = list(domain = "pM"),
                       outputFolder = "../r_results/predict_correlated_expressed_gene_granie/grn_pM",
                       genomeAssembly = "mm10")
```

Add data to GRNs (as of version 1.3.25, GRaNIE still does not allow a custom genome annotation, so it will use the latest version of the Ensembl annotation of the mouse genome):

```{r}
grn_p1 = addData(GRN = grn_p1,
                 counts_peaks = p1_region_accessibility,
                 normalization_peaks = "DESeq2_sizeFactors",
                 idColumn_peaks = "region_id",
                 counts_rna = p1_gene_expression,
                 normalization_rna = "limma_quantile",
                 idColumn_RNA = "gene_id",
                 sampleMetadata = sample_meta_p1,
                 forceRerun = T)

grn_p2 = addData(GRN = grn_p2,
                 counts_peaks = p2_region_accessibility,
                 normalization_peaks = "DESeq2_sizeFactors",
                 idColumn_peaks = "region_id",
                 counts_rna = p2_gene_expression,
                 normalization_rna = "limma_quantile",
                 idColumn_RNA = "gene_id",
                 sampleMetadata = sample_meta_p2,
                 forceRerun = T)

grn_pM = addData(GRN = grn_pM,
                 counts_peaks = pM_region_accessibility,
                 normalization_peaks = "DESeq2_sizeFactors",
                 idColumn_peaks = "region_id",
                 counts_rna = pM_gene_expression,
                 normalization_rna = "limma_quantile",
                 idColumn_RNA = "gene_id",
                 sampleMetadata = sample_meta_pM,
                 forceRerun = T)
```

PCA plot for gene expression:

```{r}
plotPCA_all(GRN = grn_p1,
            data = c("rna"),
            basenameOutput = "p1_pca",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

Samples from Day 9 and Day 11 are mostly separated by PC2, while Day 7 is not separated by PC2 from Day 9 because of one sample (WT_D7_p1_NFIAn_R3) positioned together with samples from Day 9. However, this does not make biological sense, as on Day 7 the NFIA-dependent gliogenesis program is still inactive, and for the same reason the separation of the other two Day 7 samples from the rest makes sense. Therefore, to obtain a clear separation of Day 7 samples from Day 9 and 11 samples, I will remove the "outlier" sample (WT_D7_p1_NFIAn_R3).

PCA plot for region accessibility:

```{r}
plotPCA_all(GRN = grn_p1,
            data = c("peaks"),
            basenameOutput = "p1_pca",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

Samples are very clearly grouped by the day and separated by PC1. Interestingly, the between-sample difference, compared to the between-day difference, is much smaller in region accessibility than in gene expression.

Remove sample WT_D7_p1_NFIAn_R3 from the p1 gene expression table, as discussed above:

```{r}
p1_gene_expression %<>% dplyr::select(-WT_D7_p1_NFIAn_R3)
```

Re-create the p1 GRN without the excluded sample:

```{r}
sample_meta_p1 = generate_sample_meta(p1_gene_expression, p1_region_accessibility)

grn_p1 = initializeGRN(objectMetadata = list(domain = "p1"),
                       outputFolder = "../r_results/predict_correlated_expressed_gene_granie/grn_p1",
                       genomeAssembly = "mm10")

grn_p1 = addData(GRN = grn_p1,
                 counts_peaks = p1_region_accessibility,
                 normalization_peaks = "DESeq2_sizeFactors",
                 idColumn_peaks = "region_id",
                 counts_rna = p1_gene_expression,
                 normalization_rna = "limma_quantile",
                 idColumn_RNA = "gene_id",
                 sampleMetadata = sample_meta_p1,
                 forceRerun = T)
```

Do PCA again for the p1 GRN without the excluded sample.

PCA plot for gene expression without the excluded sample:

```{r}
plotPCA_all(GRN = grn_p1,
            data = c("rna"),
            basenameOutput = "p1_pca_noout",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

Now the two remaining samples from Day 7 are clearly separated by PC1 from the samples from Day 9 and Day 11 which, in turn, are not separated from each other. This makes sense.

PCA plot for region accessibility without the excluded sample:

```{r}
plotPCA_all(GRN = grn_p1,
            data = c("peaks"),
            basenameOutput = "p1_pca_noout",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

The clear separation of samples from Day 7, 9 and 11 did not change, which makes sense (as the excluded sample was not an outlier in the original PCA plot for peak accessibility).

Make a p2-specific PCA plot for RNA-seq samples:

```{r}
plotPCA_all(GRN = grn_p2,
            data = c("rna"),
            basenameOutput = "p2_pca",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

Samples from Day 7, 9 and 11 are separated by PC2. All good. Of note, NFIA-negative samples from Day 9 group together with NFIA-positive samples from the same day and not to samples from Day 7. This fact suggests that NFIA-negative samples are not really "negative."

Make a p2-specific PCA plot for ATAC-seq samples:

```{r}
plotPCA_all(GRN = grn_p2,
            data = c("peaks"),
            basenameOutput = "p2_pca",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

Samples from Day 7, 9 and 11 are separated by PC1. All good.

Make a pM-specific PCA plot for RNA-seq samples:

```{r}
plotPCA_all(GRN = grn_pM,
            data = c("rna"),
            basenameOutput = "pM_pca",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

Samples from Day 7, 9 and 11 are separated by PC2, and samples from Day 7 are located further from the rest of the samples (along the PC2 axis) than Day 9 samples from Day 11 samples. All good. Again, NFIA-negative Day 9 samples group with NFIA-positive Day 9 samples and not with Day 7 samples, which again suggests that the "NFIA-negative" samples are actually not NFIA-negative.

Make a pM-specific PCA plot for ATAC-seq samples:

```{r}
plotPCA_all(GRN = grn_pM,
            data = c("peaks"),
            basenameOutput = "pM_pca",
            topn = 500,
            type = "normalized",
            removeFiltered = T,
            plotAsPDF = T,
            pages = c(5),
            forceRerun = T)
```

Samples from Day 7, 9 and 11 are separated by PC1. All good.

## Filter genes and peaks

Remove low-count and low-variability genes and peaks:

```{r}
grn_p1 = filterData(GRN = grn_p1,
                    minNormalizedMean_peaks = min.norm.peak.counts, 
                    minNormalizedMeanRNA = min.norm.rna.counts, 
                    forceRerun = T)

grn_p2 = filterData(GRN = grn_p2,
                    minNormalizedMean_peaks = min.norm.peak.counts, 
                    minNormalizedMeanRNA = min.norm.rna.counts, 
                    forceRerun = T)

grn_pM = filterData(GRN = grn_pM,
                    minNormalizedMean_peaks = min.norm.peak.counts, 
                    minNormalizedMeanRNA = min.norm.rna.counts,
                    forceRerun = T)
```

## Predict regulatory connections

Predict enhancer-gene connections in all the three domains:

```{r}
grn_p1 = addConnections_peak_gene(GRN = grn_p1,
                                  overlapTypeGene = "TSS",
                                  corMethod = "pearson",
                                  promoterRange = vicinity.radius,
                                  nCores = 2,
                                  plotDiagnosticPlots = T,
                                  forceRerun = T)

grn_p2 = addConnections_peak_gene(GRN = grn_p2,
                                  overlapTypeGene = "TSS",
                                  corMethod = "pearson",
                                  promoterRange = vicinity.radius,
                                  nCores = 2,
                                  plotDiagnosticPlots = T,
                                  forceRerun = T)

grn_pM = addConnections_peak_gene(GRN = grn_pM,
                                  overlapTypeGene = "TSS",
                                  corMethod = "pearson",
                                  promoterRange = vicinity.radius,
                                  nCores = 2,
                                  plotDiagnosticPlots = T,
                                  forceRerun = T)
```

Save the GRN objects:

```{r}
saveRDS(grn_p1,
        "../r_results/predict_correlated_expressed_gene_granie/grn_p1/grn_p1.rds")

saveRDS(grn_p2,
        "../r_results/predict_correlated_expressed_gene_granie/grn_p2/grn_p2.rds")

saveRDS(grn_pM,
        "../r_results/predict_correlated_expressed_gene_granie/grn_pM/grn_pM.rds")
```

For p1, the QC plots on page 1 of the corresponding PDF look good: (1) The raw p-value density for positively correlated connections for the real signal peak at at the smallest p-values (and although the density for the negatively correlated connections peaks at the same p-value range, the peak is much lower); (2) The ratio of positively correlated connections to negatively correlated connections is higher for real connections than for background connections; (3) Real connections demonstrate more extreme correlation coefficients than background connections.

For p2, the QC plots on page 1 of the corresponding PDF look worse than for p1, but still acceptable: (1) Almost the same as for p1 (looks OK); (2) The ratio of positively correlated connections to negatively correlated connections is higher for real connections than for background connections, but negligibly; (3) Real connections demonstrate more extreme correlation coefficients than background connections, but also negligibly.

For pMN, the QC plots on page 1 of the corresponding PDF look worse than for p1, but still acceptable: (1) Almost the same as for p2 (the background distributions are even less uniform than in p2 but are still OK); (2) The ratio of positively correlated connections to negatively correlated connections is higher for real connections than for background connections, but negligibly (exactly like for p2); (3) Real connections demonstrate more extreme correlation coefficients than background connections, but not as much as for p1 (although the distributions definitely look more different than for p2).

The weak dominance of positively correlated connections over negatively correlated connections in all the three domains (and especially in p2 and pMN) could be explained by either any technical problems with the data (for example, the number of samples for each domain is less than 12 which is considered the minimal number of samples for the successful GRaNIE analysis by the authors of the package) or by some biological effects (either a possible biological relevance of negative correlations between peak accessibility and gene expression, which GRaNIE authors dismiss, or a possible colocalisation of peaks and genes that are strongly positively regulated with peaks and genes that are strongly negatively regulated, so that genes under both modes of regulation would be found in any given vicinity around a peak; this possibility is in line with my previous failures to establish a working background and implies that long-range regulation that skips non-target genes and enhancers is predominant).

I tried to filter by the minimum mean normalised exression of 5 (default in GRaNIE) or 20, but then the QC becomes worse.

## Analyse the predicted connections

Extract the predicted ("real") connections:

```{r}
grn_p1 = readRDS("../r_results/predict_correlated_expressed_gene_granie/grn_p1/grn_p1.rds")

grn_p2 = readRDS("../r_results/predict_correlated_expressed_gene_granie/grn_p2/grn_p2.rds")

grn_pM = readRDS("../r_results/predict_correlated_expressed_gene_granie/grn_pM/grn_pM.rds")

grn_p1 = filterGRNAndConnectGenes(grn_p1,
                                  peak_gene.fdr.threshold = 0.2,
                                  peak_gene.fdr.method = "BH",
                                  gene.types = "all",
                                  allowMissingTFs = T,
                                  peak_gene.r_range = c(0, 1))

grn_p2 = filterGRNAndConnectGenes(grn_p2,
                                  peak_gene.fdr.threshold = 0.2,
                                  peak_gene.fdr.method = "BH",
                                  gene.types = "all",
                                  allowMissingTFs = T,
                                  peak_gene.r_range = c(0, 1))

grn_pM = filterGRNAndConnectGenes(grn_pM,
                                  peak_gene.fdr.threshold = 0.2,
                                  peak_gene.fdr.method = "BH",
                                  gene.types = "all",
                                  allowMissingTFs = T,
                                  peak_gene.r_range = c(0, 1))
```
